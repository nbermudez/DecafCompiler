%{
    #include "label_manager.h"

    string indent(int count) {
        ostringstream out;
        out << string(count, ' ');
        return out.str();
    }
    int string_count = 0;
    string getStringLabel() {
        ostringstream out;

        out << "string_" << string_count++;

        return out.str();
    }

%}

/*=====================================================================*/
/********************* Classes for Decorated Nodes *********************/
/*=====================================================================*/
%node DecoratedNode %abstract %typedef 
/*=====================================================================*/
/*** Decorated Class ***/
%node DecoratedClass DecoratedNode = {
    string name;
    %nocreate DecoratedBlockStatement *main = {NULL};
}
/*=====================================================================*/
/*** Decorated Expressions Tree ***/
%node DecoratedExpression DecoratedNode %abstract = {
    ExpressionType  *type;
    %nocreate string place = {""};
    %nocreate int line = {0};
}

%node DecoratedBinaryExpression DecoratedExpression %abstract = {
    DecoratedExpression *left;
    DecoratedExpression *right;
}

%node DecoratedAddExpression DecoratedBinaryExpression
%node DecoratedSubExpression DecoratedBinaryExpression
%node DecoratedMultExpression DecoratedBinaryExpression
%node DecoratedDivExpression DecoratedBinaryExpression
%node DecoratedModExpression DecoratedBinaryExpression
%node DecoratedAndExpression DecoratedBinaryExpression
%node DecoratedOrExpression DecoratedBinaryExpression
%node DecoratedGTExpression DecoratedBinaryExpression
%node DecoratedLTExpression DecoratedBinaryExpression
%node DecoratedGTEExpression DecoratedBinaryExpression
%node DecoratedLTEExpression DecoratedBinaryExpression
%node DecoratedEqExpression DecoratedBinaryExpression
%node DecoratedNotEqExpression DecoratedBinaryExpression
%node DecoratedRShiftExpression DecoratedBinaryExpression
%node DecoratedLShiftExpression DecoratedBinaryExpression
%node DecoratedRotExpression DecoratedBinaryExpression

%node DecoratedUnaryExpression DecoratedExpression %abstract = {
    DecoratedExpression *expression;
}

%node DecoratedNotExpression DecoratedUnaryExpression
%node DecoratedNegExpression DecoratedUnaryExpression

%node DecoratedConstant DecoratedExpression %abstract
%node DecoratedBooleanConstant DecoratedConstant = {
    bool value;
}

%node DecoratedIntConstant DecoratedConstant = {
    int value;
}

%node DecoratedStringConstant DecoratedConstant = {
    string value;
}

%node DecoratedLValue DecoratedExpression = {
    string variable_name;
    DecoratedExpression *array_index;

    %nocreate int deepLevel = {0};
    %nocreate int offset = {0};
}

%node DecoratedMethodCallExpression DecoratedExpression = {
    string name;
    DecoratedExpressionList *arguments;
}

/*=====================================================================*/
/************** Decorated Statements Tree **************/
%node DecoratedStatement DecoratedNode %abstract = {
    int line;
}

%node DecoratedAssignmentStatement DecoratedStatement = {
    DecoratedLValue *lvalue;
    DecoratedExpression *value;
}

%node DecoratedMethodCallStatement DecoratedStatement = {
    %nocreate int                     method_index = {0};
    string name;
    DecoratedExpressionList *arguments;
}

%node DecoratedPrintStatement DecoratedStatement = {
    DecoratedExpressionList *arguments;
}

%node DecoratedReadStatement DecoratedStatement = {
    DecoratedExpressionList *arguments;
}

%node DecoratedIfStatement DecoratedStatement = {
    DecoratedExpression *condition;
    DecoratedStatement  *true_part;
    DecoratedStatement  *false_part;
}

%node DecoratedWhileStatement DecoratedStatement = {
    DecoratedExpression *condition;
    DecoratedStatement  *loop_body;
}

%node DecoratedForStatement DecoratedStatement = {
    DecoratedStatement      *assignment_list1;
    DecoratedExpression     *condition;
    DecoratedStatement      *assignment_list2;
    DecoratedStatement      *loop_body;
}

%node DecoratedReturnStatement DecoratedStatement = {
    DecoratedExpression *expression;
}

%node DecoratedBreakStatement DecoratedStatement
%node DecoratedContinueStatement DecoratedStatement

%node DecoratedBlockStatement DecoratedStatement = {
    DecoratedStatementList  *statement_list;
    %nocreate DecoratedBlockStatement *parent = {NULL};
    %nocreate int deepLevel = {0};
}

/*=====================================================================*/
/*** Operations for Statement Tree ***/
%operation %virtual string generateCode([DecoratedNode *this], int indentLevel)

generateCode(DecoratedAddExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "add " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedSubExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "sub " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedMultExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "mul " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedDivExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "div " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedModExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "rem " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedAndExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();

    string lblFalse, lblEnd;
    lblFalse = LabelManager::getInstance().getFalseLabel();
    lblEnd = LabelManager::getInstance().getEndLabel();
    
    out << indent(indentLevel) << "beq " << left->place << ", $zero, " << lblFalse << endl;
    out << indent(indentLevel) << "beq " << right->place << ", $zero, " << lblFalse << endl;
    out << indent(indentLevel) << "li " << reg << ", 1" << endl;
    out << indent(indentLevel) << "j " << lblEnd;
    out << indent(indentLevel) << lblFalse << ":" << endl;
    out << indent(indentLevel) << "li " << reg << ", 0" << endl;
    out << indent(indentLevel) << lblEnd << endl;

    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedOrExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();

    string lblTrue, lblEnd;

    lblTrue = LabelManager::getInstance().getTrueLabel();
    lblEnd = LabelManager::getInstance().getEndLabel();
    
    out << indent(indentLevel) << "bne " << left->place << ", $zero, " << lblTrue << endl;
    out << indent(indentLevel) << "bne " << right->place << ", $zero, " << lblTrue << endl;
    out << indent(indentLevel) << "li " << reg << ", 0" << endl;
    out << indent(indentLevel) << "j " << lblEnd;
    out << indent(indentLevel) << lblTrue << ":" << endl;
    out << indent(indentLevel) << "li " << reg << ", 1" << endl;
    out << indent(indentLevel) << lblEnd << endl;

    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedGTExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "slt " << reg << ", " <<right->place << ", " << left->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedLTExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "slt " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedGTEExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "sle " << reg << ", " <<right->place << ", " << left->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedLTEExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "sle " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedEqExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "seq " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedNotEqExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "sne " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedRShiftExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "srlv " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedLShiftExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "sllv " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedRotExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "ror " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedNotExpression) {
    ostringstream out;
    
    out << expression->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(expression->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "seq " << reg << ", $zero, " << expression->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedNegExpression) {
    ostringstream out;
    
    out << expression->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(expression->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "sub " << reg << ", $zero, " << expression->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedBooleanConstant) {
    ostringstream out;
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();

    if (value) {
        out << indent(indentLevel) << "li " << reg << ", 1" << endl; 
    } else {
        out << indent(indentLevel) << "li " << reg << ", 0" << endl;
    }
    this->place = reg;

    return out.str();
}

generateCode(DecoratedIntConstant) {
    ostringstream out;
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();

    out << indent(indentLevel) << "li " << reg << ", " << value << endl;
    this->place = reg;

    return out.str();
}

generateCode(DecoratedStringConstant) {
    ostringstream out;

    string reg;
    reg = RegisterManager::getInstance().getTempRegister();

    out << indent(indentLevel + 1) << "la " << reg << ", " 
        << getSymbolTableInstance()->getString(value) << endl;
    this->place = reg;

    return out.str();
}

generateCode(DecoratedLValue) {
    ostringstream out;

    string reg;
    reg = RegisterManager::getInstance().getTempRegister();

    Variable* var = currentFunction->findParameter(variable_name);
    if (var != NULL) {
        out << indent(indentLevel) << "move " << reg << ", " << "$a" << ((SimpleVariable*)var)->parameterId << endl;
    } else {

        out << indent(indentLevel) << "la " << reg << ", " << variable_name << endl;
        if (array_index != NULL) {
            out << array_index->generateCode(indentLevel + 1);
            out << indent(indentLevel + 1) << "sll " << array_index->place 
                << ", " << array_index->place << ", 2" << endl;
            out << indent(indentLevel) << "add " << reg << ", " << reg << ", " 
                << array_index->place << endl;
        }
        out << indent(indentLevel) << "lw " << reg << ", 0(" << reg << ")" << endl;
        
    }
    this->place =  reg;

    return out.str();
}

generateCode(DecoratedMethodCallExpression) {
    ostringstream out;

    list<DecoratedExpression*>::iterator it = arguments->begin();
    int argc = 0;
    while (it != arguments->end()) {
        DecoratedExpression *argument = (*it);
        if (argc < 5) {
            //usar $a0...$a4
            string param;
            param = RegisterManager::getInstance().getParamRegister();

            out << argument->generateCode(indentLevel + 1);
            out << indent(indentLevel) << "move " << param << " ," << argument->place << endl;
            RegisterManager::getInstance().freeRegister(argument->place);
        } else {
            //poner en la pila
        }
        it++;
    }
    //TODO:save registers
    out << indent(indentLevel) << "jal " << name << endl;
    //TODO:restore registers

    RegisterManager::getInstance().freeParamRegisters();
    
    this->place = "$v0";

    return out.str();
}

/*************************************************************/
generateCode(DecoratedAssignmentStatement) {
    ostringstream out;

    out << lvalue->getLocation(indentLevel + 1);
    out << value->generateCode(indentLevel + 1);
    out << indent(indentLevel) << "sw " << value->place << ", 0(" << lvalue->place << ")" << endl;

    RegisterManager::getInstance().freeRegister(lvalue->place);
    RegisterManager::getInstance().freeRegister(value->place);

    return out.str();
}

generateCode(DecoratedMethodCallStatement) {
    ostringstream out;

    list<DecoratedExpression*>::iterator it = arguments->begin();
    int argc = 0;
    while (it != arguments->end()) {
        DecoratedExpression *argument = (*it);
        if (argc < 5) {
            //usar $a0...$a4
            string param;
            param = RegisterManager::getInstance().getParamRegister();

            out << argument->generateCode(indentLevel + 1);
            out << indent(indentLevel) << "move " << param << " ," << argument->place << endl;
            RegisterManager::getInstance().freeRegister(argument->place);
        } else {
            //poner en la pila
        }
        it++;
    }
    //TODO:save registers
    out << indent(indentLevel) << "jal " << name << endl;
    //TODO:restore registers

    RegisterManager::getInstance().freeParamRegisters();

    return out.str();
}

generateCode(DecoratedPrintStatement) {
    ostringstream out;

    list<DecoratedExpression *>::iterator argument = arguments->begin();
    while (argument != arguments->end()) {
        DecoratedExpression *expression = (*argument);

        out << expression->generateCode(indentLevel + 1);

        int printType = 4;
        if (!expression->type->isEquivalent(new StringType()))
            printType = 1;

        out << indent(indentLevel) << "move $a0, " << expression->place << endl;
        out << indent(indentLevel) << "li $v0, " << printType << endl;
        out << indent(indentLevel) << "syscall" << endl;

        RegisterManager::getInstance().freeRegister(expression->place);

        argument++;
    }

    return out.str();
}

generateCode(DecoratedReadStatement) {
    ostringstream out;

    list<DecoratedExpression *>::iterator argument = arguments->begin();
    while (argument != arguments->end()) {
        DecoratedLValue *arg = (DecoratedLValue*)(*argument);       
        
        out << indent(indentLevel) << "li $v0, 5" << endl;
        out << indent(indentLevel) << "syscall" << endl;

        out << arg->getLocation(indentLevel + 1);

        //TODO: con variables locales donde se guardar√°?
        out << indent(indentLevel) << "sw $v0, 0(" << arg->place << ")" << endl;

        argument++;
    }

    return out.str();
}

generateCode(DecoratedIfStatement) {
    ostringstream out;

    out << condition->generateCode(indentLevel);

    string elseLabel;
    elseLabel = LabelManager::getInstance().getElseLabel();

    out << indent(indentLevel) << "beq " << condition->place << ", $zero, " << elseLabel << endl;
    out << true_part->generateCode(indentLevel + 1) << endl;
    out << indent(indentLevel) << elseLabel << ":" << endl;
    if (false_part != NULL) {
        out << false_part->generateCode(indentLevel + 1) << endl;
    }

    return out.str();
}

generateCode(DecoratedWhileStatement) {
    ostringstream out;

    string whileLabel;
    string outOfWhileLabel;
    whileLabel = LabelManager::getInstance().getWhileLabel();
    outOfWhileLabel = LabelManager::getInstance().getOutOfWhileLabel();

    LabelManager::getInstance().pushBreakPoint(outOfWhileLabel);
    LabelManager::getInstance().pushContinuePoint(whileLabel);

    out << indent(indentLevel) << whileLabel << ":" << endl;

    out << condition->generateCode(indentLevel + 1) ;
    out << indent(indentLevel + 1) << "beq " << condition->place << ", $zero, " << outOfWhileLabel << endl;

    out << loop_body->generateCode(indentLevel + 1);
    out << indent(indentLevel) << "j " << whileLabel << endl;

    out << indent(indentLevel) << outOfWhileLabel << ":" << endl;

    LabelManager::getInstance().popContinuePoint();
    LabelManager::getInstance().popCurrentBreakPoint();

    return out.str();
}

generateCode(DecoratedForStatement) {
    ostringstream out;

    string forLabel;
    string outOfForLabel;
    string continuePoint;

    forLabel = LabelManager::getInstance().getForLabel();
    outOfForLabel = LabelManager::getInstance().getOutOfForLabel();
    continuePoint = LabelManager::getInstance().getContinueLabel();


    LabelManager::getInstance().pushBreakPoint(outOfForLabel);
    LabelManager::getInstance().pushContinuePoint(continuePoint);

    out << assignment_list1->generateCode(indentLevel + 1);

    out << indent(indentLevel) << forLabel << ":" << endl;

    out << condition->generateCode(indentLevel + 1);
    out << indent(indentLevel + 1) << "beq " << condition->place << ", $zero, " << outOfForLabel << endl;

    out << loop_body->generateCode(indentLevel + 1);

    out << indent(indentLevel + 1) << continuePoint << ": " << endl;
    
    out << assignment_list2->generateCode(indentLevel + 1);

    out << indent(indentLevel) << "j " << forLabel << endl;

    out << indent(indentLevel) << outOfForLabel << ":" << endl;

    LabelManager::getInstance().popContinuePoint();
    LabelManager::getInstance().popCurrentBreakPoint();

    return out.str();
}

generateCode(DecoratedReturnStatement) {
    ostringstream out;
    if (expression != NULL) {
        out << expression->generateCode(indentLevel + 1);
        out << indent(indentLevel) << "move $v0, " << expression->place << endl;

        //epilogo
        
    }
    out << indent(indentLevel) << "jr $ra" << endl;
    return out.str();
}

generateCode(DecoratedBreakStatement) {
    ostringstream out;

    out << indent(indentLevel) << "j " << LabelManager::getInstance().getCurrentBreakPoint() << endl;

    return out.str();
}

generateCode(DecoratedContinueStatement) {
    ostringstream out;

    out << indent(indentLevel) << "j " << LabelManager::getInstance().getCurrentContinuePoint() << endl;

    return out.str();
}

generateCode(DecoratedBlockStatement) {
    if (deepLevel >= MAX_DEEP_NESTING) {
        ostringstream out;
        out << "nesting level cannot be greater than " << MAX_DEEP_NESTING;
        ErrorHandler::getInstance().handleFatal(line, out.str());
    }
    ostringstream out;

    list<DecoratedStatement*>::iterator it = statement_list->begin();
    out << indent(indentLevel) << "# scope level " << deepLevel << endl;

    while (it != statement_list->end()) {
        out << (*it)->generateCode(indentLevel + 1);

        it++;
    }
    out << indent(indentLevel) << "# end of scope level " << deepLevel << endl;


    return out.str();
}
/*************************************************************/
generateCode(DecoratedClass) {
    ostringstream out;

    out << ".data" << endl;

    /*********************** Registering Variables **********************/
    map<string, Variable*> *variables = getSymbolTableInstance()->getVariables();
    map<string, Variable*>::iterator variable_it = variables->begin();

    while (variable_it != variables->end()) {
        Variable *variable = variable_it->second;

        out << variable_it->first ;
        SimpleVariable *simpleVariable = dynamic_cast<SimpleVariable*>(variable);
        if (simpleVariable != NULL) {
            out << ": .word ";
            if (variable->initialized) {
                if (((DecoratedIntConstant*)simpleVariable->initial_value) != NULL)
                    out << ((DecoratedIntConstant*)simpleVariable->initial_value)->value << endl;
                else
                    out << ((DecoratedBooleanConstant*)simpleVariable->initial_value)->value << endl;
            } else {
                out << 0 << endl;
            }
        } else {
            int size = ((ArrayVariable*)variable)->size;
            out << ": .space " << (size * 4) << " # " << size << " integers" << endl;
        }
        variable_it++;
    }

    /*********************** Registering Strings **********************/

    map<string, string> *strings = getSymbolTableInstance()->getStrings();
    map<string, string>::iterator string_it = strings->begin();

    while (string_it != strings->end()) {
        out << string_it->second << ": .asciiz " << string_it->first << endl;
        string_it++;
    }

    out << endl << endl;

     /*********************** Registering Functions **********************/

    out << ".text" << endl;
    out << this->name << ":" << endl;
    out << "j main" << endl << endl;

    map<string, Function*> *functions = getSymbolTableInstance()->getFunctions();
    map<string, Function*>::iterator function = functions->begin();

    while (function != functions->end()) {

        out << indent(indentLevel) << function->first << ":" << endl;
        currentFunction = function->second;

        out << indent(indentLevel) << "#prologo ..." << endl;
        out << indent(indentLevel) << "add $sp, $sp, " << currentFunction->activation_size << endl << endl;
        if (function->second->body != NULL)
            out << function->second->body->generateCode(indentLevel + 1);

        if (function->first == "main") {
            out << indent(indentLevel) << "li $v0, 10" << endl;
            out << indent(indentLevel) << "syscall" << endl;
        }

        RegisterManager::getInstance().freeAllRegisters();

        out << indent(indentLevel) << "#epilogo ..." << endl;
        out << indent(indentLevel) << "add $sp, $sp, -" << currentFunction->activation_size << endl << endl;

        out << endl << endl;

        function++;
    }
    return out.str();
}
/*************************************************************/
%operation %virtual string getLocation([DecoratedLValue *this], int indentLevel);

getLocation(DecoratedLValue) {
    ostringstream out;

    string reg;
    reg = RegisterManager::getInstance().getSavedRegister();

    out << indent(indentLevel) << "la " << reg << ", " << variable_name << endl;
    if (array_index != NULL) {
        out << array_index->generateCode(indentLevel + 1);
        out << indent(indentLevel + 1) << "sll " << array_index->place 
            << ", " << array_index->place << ", 2" << "# multiply by 4" << endl;
        out << indent(indentLevel) << "add " << reg << ", " << reg << ", " 
            << array_index->place << endl;
    }
    this->place =  reg;

    return out.str();
}