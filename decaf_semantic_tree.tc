%{
    #include "label_manager.h"

    string indent(int count) {
        ostringstream out;
        out << string(count, ' ');
        return out.str();
    }
    int string_count = 0;
    string getStringLabel() {
        ostringstream out;

        out << "string_" << string_count++;

        return out.str();
    }

    string function_end;
    string current_function_epilog;

    string formatUnregisterLogic(string unregisterLogic) {
        string formated = unregisterLogic;
        string displayAddress = RegisterManager::getInstance().getTempRegister();
        string displayItem = RegisterManager::getInstance().getTempRegister();

        int displayAddressPos = formated.find("displayAddress");
        while (displayAddressPos != string::npos) {
            formated.replace(displayAddressPos, 14, displayAddress);
            displayAddressPos = formated.find("displayAddress");
        }

        int displayItemPos = formated.find("displayItem");
        while (displayItemPos != string::npos) {
            formated.replace(displayItemPos, 11, displayItem);
            displayItemPos = formated.find("displayItem");
        }

        RegisterManager::getInstance().freeRegister(displayAddress);
        RegisterManager::getInstance().freeRegister(displayItem);
        return formated;
    }

    string unregisterBlocksLoop() {
        ostringstream out;
        stack<string> texts;
        stack<bool> belongs;
        while (!ContextManager::getInstance().belongsToLoop()) {
            string unregisterLogic = ContextManager::getInstance().getUnregisterLogic();
            texts.push(unregisterLogic);
            ContextManager::getInstance().popUnregisterLogic();
            belongs.push(false);

            unregisterLogic = formatUnregisterLogic(unregisterLogic);

            out << unregisterLogic << endl;

        }
        out << formatUnregisterLogic(ContextManager::getInstance().getUnregisterLogic());

        while (texts.size()>0) {
            ContextManager::getInstance().pushUnregisterLogic(texts.top(), belongs.top());
            texts.pop();            
            belongs.pop();
        }

        return out.str();
    }

    string unregisterAll() {
        ostringstream out;
        stack<string> texts;
        stack<bool> belongs;
        while (!ContextManager::getInstance().unregisterLogicsIsEmpty()) {
            string unregisterLogic = ContextManager::getInstance().getUnregisterLogic();
            texts.push(unregisterLogic);
            ContextManager::getInstance().popUnregisterLogic();
            belongs.push(false);

            unregisterLogic = formatUnregisterLogic(unregisterLogic);

            out << unregisterLogic << endl;
        }

        while (texts.size()>0) {
            ContextManager::getInstance().pushUnregisterLogic(texts.top(), belongs.top());
            texts.pop();            
            belongs.pop();
        }

        return out.str();
    }
    
%}

/*=====================================================================*/
/********************* Classes for Decorated Nodes *********************/
/*=====================================================================*/
%node DecoratedNode %abstract %typedef 
/*=====================================================================*/
/*** Decorated Class ***/
%node DecoratedClass DecoratedNode = {
    string name;
    %nocreate DecoratedBlockStatement *main = {NULL};
}
/*=====================================================================*/
/*** Decorated Expressions Tree ***/
%node DecoratedExpression DecoratedNode %abstract = {
    ExpressionType  *type;
    %nocreate string place = {""};
    %nocreate int line = {0};
}

%node DecoratedBinaryExpression DecoratedExpression %abstract = {
    DecoratedExpression *left;
    DecoratedExpression *right;
}

%node DecoratedAddExpression DecoratedBinaryExpression
%node DecoratedSubExpression DecoratedBinaryExpression
%node DecoratedMultExpression DecoratedBinaryExpression
%node DecoratedDivExpression DecoratedBinaryExpression
%node DecoratedModExpression DecoratedBinaryExpression
%node DecoratedAndExpression DecoratedBinaryExpression
%node DecoratedOrExpression DecoratedBinaryExpression
%node DecoratedGTExpression DecoratedBinaryExpression
%node DecoratedLTExpression DecoratedBinaryExpression
%node DecoratedGTEExpression DecoratedBinaryExpression
%node DecoratedLTEExpression DecoratedBinaryExpression
%node DecoratedEqExpression DecoratedBinaryExpression
%node DecoratedNotEqExpression DecoratedBinaryExpression
%node DecoratedRShiftExpression DecoratedBinaryExpression
%node DecoratedLShiftExpression DecoratedBinaryExpression
%node DecoratedRotExpression DecoratedBinaryExpression

%node DecoratedUnaryExpression DecoratedExpression %abstract = {
    DecoratedExpression *expression;
}

%node DecoratedNotExpression DecoratedUnaryExpression
%node DecoratedNegExpression DecoratedUnaryExpression

%node DecoratedConstant DecoratedExpression %abstract
%node DecoratedBooleanConstant DecoratedConstant = {
    bool value;
}

%node DecoratedIntConstant DecoratedConstant = {
    int value;
}

%node DecoratedStringConstant DecoratedConstant = {
    string value;
}

%node DecoratedLValue DecoratedExpression = {
    string variable_name;
    DecoratedExpression *array_index;

    %nocreate int deepLevel = {0};
    %nocreate int offset = {0};
    %nocreate bool isGlobal = {false};
    %nocreate bool isParameter = {false};
}

%node DecoratedMethodCallExpression DecoratedExpression = {
    string name;
    DecoratedExpressionList *arguments;
}

/*=====================================================================*/
/************** Decorated Statements Tree **************/
%node DecoratedStatement DecoratedNode %abstract = {
    int line;
}

%node DecoratedAssignmentStatement DecoratedStatement = {
    DecoratedLValue *lvalue;
    DecoratedExpression *value;
}

%node DecoratedMethodCallStatement DecoratedStatement = {
    %nocreate int                     method_index = {0};
    string name;
    DecoratedExpressionList *arguments;
}

%node DecoratedPrintStatement DecoratedStatement = {
    DecoratedExpressionList *arguments;
}

%node DecoratedReadStatement DecoratedStatement = {
    DecoratedExpressionList *arguments;
}

%node DecoratedIfStatement DecoratedStatement = {
    DecoratedExpression *condition;
    DecoratedStatement  *true_part;
    DecoratedStatement  *false_part;
}

%node DecoratedWhileStatement DecoratedStatement = {
    DecoratedExpression *condition;
    DecoratedStatement  *loop_body;
}

%node DecoratedForStatement DecoratedStatement = {
    DecoratedStatement      *assignment_list1;
    DecoratedExpression     *condition;
    DecoratedStatement      *assignment_list2;
    DecoratedStatement      *loop_body;
}

%node DecoratedReturnStatement DecoratedStatement = {
    DecoratedExpression *expression;
}

%node DecoratedBreakStatement DecoratedStatement
%node DecoratedContinueStatement DecoratedStatement

%node DecoratedBlockStatement DecoratedStatement = {
    DecoratedStatementList  *statement_list;
    %nocreate DecoratedBlockStatement *parent = {NULL};
    %nocreate int deepLevel = {0};
    %nocreate int scopeSize = {0};
    %nocreate Context* context = {NULL};
    %nocreate bool belongsToLoop = {false};
}

/*=====================================================================*/
/*** Operations for Statement Tree ***/
%operation %virtual string generateCode([DecoratedNode *this], int indentLevel)

generateCode(DecoratedAddExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    string reg_left = left->place;
    if (left->place == "$v0") {
        reg_left = RegisterManager::getInstance().getSavedRegister();
        out << indent(indentLevel) << "move " << reg_left << ", $v0" << endl;
    }
    out << right->generateCode(indentLevel + 1);
    string reg_right = right->place;
    if (right->place == "$v0") {
        reg_right = RegisterManager::getInstance().getSavedRegister();
        out << indent(indentLevel) << "move " << reg_right << ", $v0" << endl;
    }
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "add " << reg << ", " << reg_left << ", " << reg_right << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedSubExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "sub " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedMultExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "mul " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedDivExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "div " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedModExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "rem " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedAndExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();

    string lblFalse, lblEnd;
    lblFalse = LabelManager::getInstance().getFalseLabel();
    lblEnd = LabelManager::getInstance().getEndLabel();
    
    out << indent(indentLevel) << "beq " << left->place << ", $zero, " << lblFalse << endl;
    out << indent(indentLevel) << "beq " << right->place << ", $zero, " << lblFalse << endl;
    out << indent(indentLevel) << "li " << reg << ", 1" << endl;
    out << indent(indentLevel) << "j " << lblEnd << endl;
    out << indent(indentLevel) << lblFalse << ":" << endl;
    out << indent(indentLevel) << "li " << reg << ", 0" << endl;
    out << indent(indentLevel) << lblEnd << ": " << endl;

    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedOrExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();

    string lblTrue, lblEnd;

    lblTrue = LabelManager::getInstance().getTrueLabel();
    lblEnd = LabelManager::getInstance().getEndLabel();
    
    out << indent(indentLevel) << "bne " << left->place << ", $zero, " << lblTrue << endl;
    out << indent(indentLevel) << "bne " << right->place << ", $zero, " << lblTrue << endl;
    out << indent(indentLevel) << "li " << reg << ", 0" << endl;
    out << indent(indentLevel) << "j " << lblEnd << endl;
    out << indent(indentLevel) << lblTrue << ":" << endl;
    out << indent(indentLevel) << "li " << reg << ", 1" << endl;
    out << indent(indentLevel) << lblEnd << ":" << endl;

    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedGTExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "slt " << reg << ", " <<right->place << ", " << left->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedLTExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "slt " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedGTEExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "sle " << reg << ", " <<right->place << ", " << left->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedLTEExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "sle " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedEqExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "seq " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedNotEqExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "sne " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedRShiftExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "srlv " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedLShiftExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "sllv " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedRotExpression) {
    ostringstream out;
    
    out << left->generateCode(indentLevel + 1);
    out << right->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(left->place);
    RegisterManager::getInstance().freeRegister(right->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "ror " << reg << ", " <<left->place << ", " << right->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedNotExpression) {
    ostringstream out;
    
    out << expression->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(expression->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "seq " << reg << ", $zero, " << expression->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedNegExpression) {
    ostringstream out;
    
    out << expression->generateCode(indentLevel + 1);
    
    RegisterManager::getInstance().freeRegister(expression->place);
    
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();
    
    out << indent(indentLevel) << "sub " << reg << ", $zero, " << expression->place << endl;
    this->place = reg;
    
    return out.str();
}

generateCode(DecoratedBooleanConstant) {
    ostringstream out;
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();

    if (value) {
        out << indent(indentLevel) << "li " << reg << ", 1" << endl; 
    } else {
        out << indent(indentLevel) << "li " << reg << ", 0" << endl;
    }
    this->place = reg;

    return out.str();
}

generateCode(DecoratedIntConstant) {
    ostringstream out;
    string reg;
    reg = RegisterManager::getInstance().getTempRegister();

    out << indent(indentLevel) << "li " << reg << ", " << value << endl;
    this->place = reg;

    return out.str();
}

generateCode(DecoratedStringConstant) {
    ostringstream out;

    string reg;
    reg = RegisterManager::getInstance().getTempRegister();

    out << indent(indentLevel + 1) << "la " << reg << ", " 
        << getSymbolTableInstance()->getString(value) << endl;
    this->place = reg;

    return out.str();
}

generateCode(DecoratedLValue) {
    ostringstream out;

    string reg = RegisterManager::getInstance().getSavedRegister();
    Context *context = ContextManager::getInstance().getContext(this->deepLevel);

    string indentation = indent(indentLevel);
    out << indentation << "# " << variable_name << endl;

    if (isGlobal) {
        
        out << indentation << "la " << reg << ", " << variable_name << endl;
        if (array_index != NULL) {
            out << array_index->generateCode(indentLevel + 1);
            out << indent(indentLevel + 1) << "sll " << array_index->place 
                << ", " << array_index->place << ", 2" << "# multiply by 4" << endl;
            out << indentation << "add " << reg << ", " << reg << ", " 
                << array_index->place << endl;
        }
        
    } else if (isParameter) {
        out << indentation << "addi " << reg << ", $fp, " << this->offset << endl;
        out << indentation << "#param: " << variable_name << " offset " << this->offset << endl;
    } else {
        out << indentation << "la " << reg << ", display" << endl;
        out << indentation << "addi " << reg << ", " << reg << ", " << (this->deepLevel*4) << endl;
        out << indentation << "lw " << reg << ", 0(" << reg << ")" << endl;
        out << indentation << "addi " << reg << ", " << reg << ", " << context->transformOffset(this->offset) << endl;
        out << indentation << "#local: " << variable_name << " offset " << this->offset
            << " level " << this->deepLevel << endl;
    }
    out << indentation << "lw " << reg << ", 0(" << reg << ")" << endl;
    this->place =  reg;

    return out.str();
}

generateCode(DecoratedMethodCallExpression) {
    ostringstream out; 

    string indentation = indent(indentLevel + 1);

    list<DecoratedExpression*>::iterator it = arguments->begin();
    int argc = 0;
    out << indentation << "#method call " << name << endl;
    list<string> toSaveRegisters;
    int offset = 0;
    int paramsInReg = arguments->size()/* >= 4? arguments->size() - 4: 0*/;

    out << indentation << "addi $sp, $sp, " << (-4*paramsInReg) << "#arguments" << endl;

    while (it != arguments->end()) {
        DecoratedExpression *argument = (*it);
        if (argc < 4) {//usar $a0...$a3
            string param;
            param = RegisterManager::getInstance().getParamRegister();

            out << argument->generateCode(indentLevel + 1);
            out << indentation << "#saving previous value" << endl;
            toSaveRegisters.push_front(param);
            out << indentation << "sw " << param << ", " << offset << "($sp)" << endl;
            offset += 4;
            
            out << indentation << "#end saving" << endl;
            out << indent(indentLevel) << "move " << param << ", " << argument->place << endl;
            RegisterManager::getInstance().freeRegister(argument->place);
            argc += 1;
        } else {
            out << argument->generateCode(indentLevel + 1);
            out << indentation << "sw " << argument->place << ", " << offset << "($sp)" << endl;
            offset += 4;
        }
        it++;
    }
    
    out << indent(indentLevel) << "jal " << name << endl;

    list<string>::iterator string_iterator = toSaveRegisters.begin();
    int size = offset;
    offset = 0;
    while (string_iterator != toSaveRegisters.end()) {        
        out << indentation << "lw " << (*string_iterator) << ", " << offset << "($sp)" << endl;
        offset += 4;     
        
        string_iterator++;
    }
    out << indentation << "addi $sp, $sp, " << size << endl;

    out << indentation << "#end method call" << name << endl;

    RegisterManager::getInstance().freeParamRegisters();
    
    this->place = "$v0";

    return out.str();
}

/*************************************************************/
generateCode(DecoratedAssignmentStatement) {
    ostringstream out;
    
    out << value->generateCode(indentLevel + 1);
    out << lvalue->getLocation(indentLevel + 1);
    out << indent(indentLevel) << "sw " << value->place << ", 0(" << lvalue->place << ")" << endl;
    out << "#termino assignment..." << endl;

    RegisterManager::getInstance().freeRegister(lvalue->place);
    RegisterManager::getInstance().freeRegister(value->place);

    return out.str();
}

generateCode(DecoratedMethodCallStatement) {
    ostringstream out; 

    string indentation = indent(indentLevel + 1);

    list<DecoratedExpression*>::iterator it = arguments->begin();
    int argc = 0;
    out << indentation << "#method call " << name << endl;
    list<string> toSaveRegisters;
    int offset = 0;
    int paramsInReg = arguments->size()/* >= 4? arguments->size() - 4: 0*/;

    out << indentation << "addi $sp, $sp, " << (-4*paramsInReg) << "#arguments" << endl;

    while (it != arguments->end()) {
        DecoratedExpression *argument = (*it);
        if (argc < 4) {//usar $a0...$a3
            string param;
            param = RegisterManager::getInstance().getParamRegister();

            out << argument->generateCode(indentLevel + 1);
            out << indentation << "#saving previous value" << endl;
            toSaveRegisters.push_front(param);
            out << indentation << "sw " << param << ", " << offset << "($sp)" << endl;
            offset += 4;
            
            out << indentation << "#end saving" << endl;
            out << indent(indentLevel) << "move " << param << ", " << argument->place << endl;
            RegisterManager::getInstance().freeRegister(argument->place);
            argc += 1;
        } else {
            out << argument->generateCode(indentLevel + 1);
            out << indentation << "sw " << argument->place << ", " << offset << "($sp)" << endl;
            offset += 4;
        }
        it++;
    }
    
    out << indent(indentLevel) << "jal " << name << endl;

    list<string>::iterator string_iterator = toSaveRegisters.begin();
    int size = offset;
    offset = 0;
    while (string_iterator != toSaveRegisters.end()) {        
        out << indentation << "lw " << (*string_iterator) << ", " << offset << "($sp)" << endl;
        offset += 4;     
        
        string_iterator++;
    }
    out << indentation << "addi $sp, $sp, " << size << endl;

    out << indentation << "#end method call" << name << endl;

    RegisterManager::getInstance().freeParamRegisters();

    return out.str();
}

generateCode(DecoratedPrintStatement) {
    ostringstream out;

    list<DecoratedExpression *>::iterator argument = arguments->begin();
    while (argument != arguments->end()) {
        DecoratedExpression *expression = (*argument);

        out << expression->generateCode(indentLevel + 1);

        int printType = 4;
        if (!expression->type->isEquivalent(new StringType()))
            printType = 1;

        out << indent(indentLevel) << "move $a0, " << expression->place << endl;
        out << indent(indentLevel) << "li $v0, " << printType << endl;
        out << indent(indentLevel) << "syscall" << endl;

        RegisterManager::getInstance().freeRegister(expression->place);

        argument++;
    }

    return out.str();
}

generateCode(DecoratedReadStatement) {
    ostringstream out;

    list<DecoratedExpression *>::iterator argument = arguments->begin();
    while (argument != arguments->end()) {
        DecoratedLValue *arg = (DecoratedLValue*)(*argument);       
        
        out << indent(indentLevel) << "li $v0, 5" << endl;
        out << indent(indentLevel) << "syscall" << endl;

        out << arg->getLocation(indentLevel + 1);

        //TODO: con variables locales donde se guardará?
        out << indent(indentLevel) << "sw $v0, 0(" << arg->place << ")" << endl;

        argument++;
    }

    return out.str();
}

generateCode(DecoratedIfStatement) {
    ostringstream out;

    out << condition->generateCode(indentLevel);

    string elseLabel;
    elseLabel = LabelManager::getInstance().getElseLabel();

    out << indent(indentLevel) << "beq " << condition->place << ", $zero, " << elseLabel << endl;
    out << true_part->generateCode(indentLevel + 1) << endl;
    out << indent(indentLevel) << elseLabel << ":" << endl;
    if (false_part != NULL) {
        out << false_part->generateCode(indentLevel + 1) << endl;
    }

    RegisterManager::getInstance().freeRegister(condition->place);

    return out.str();
}

generateCode(DecoratedWhileStatement) {
    ostringstream out;

    string whileLabel;
    string outOfWhileLabel;
    whileLabel = LabelManager::getInstance().getWhileLabel();
    outOfWhileLabel = LabelManager::getInstance().getOutOfWhileLabel();

    LabelManager::getInstance().pushBreakPoint(outOfWhileLabel);
    LabelManager::getInstance().pushContinuePoint(whileLabel);

    out << indent(indentLevel) << whileLabel << ":" << endl;

    out << condition->generateCode(indentLevel + 1) ;
    out << indent(indentLevel + 1) << "beq " << condition->place << ", $zero, " << outOfWhileLabel << endl;

    out << loop_body->generateCode(indentLevel + 1);
   
    out << indent(indentLevel) << "j " << whileLabel << endl;

    out << indent(indentLevel) << outOfWhileLabel << ":" << endl;

    LabelManager::getInstance().popContinuePoint();
    LabelManager::getInstance().popCurrentBreakPoint();

    return out.str();
}

generateCode(DecoratedForStatement) {
    ostringstream out;

    string forLabel;
    string outOfForLabel;
    string continuePoint;

    forLabel = LabelManager::getInstance().getForLabel();
    outOfForLabel = LabelManager::getInstance().getOutOfForLabel();
    continuePoint = LabelManager::getInstance().getContinueLabel();


    LabelManager::getInstance().pushBreakPoint(outOfForLabel);
    LabelManager::getInstance().pushContinuePoint(continuePoint);

    out << assignment_list1->generateCode(indentLevel + 1);

    out << indent(indentLevel) << forLabel << ":" << endl;

    out << condition->generateCode(indentLevel + 1);
    out << indent(indentLevel + 1) << "beq " << condition->place << ", $zero, " << outOfForLabel << endl;

    out << loop_body->generateCode(indentLevel + 1);

    out << indent(indentLevel + 1) << continuePoint << ": " << endl;
    
    out << assignment_list2->generateCode(indentLevel + 1);

    out << indent(indentLevel) << "j " << forLabel << endl;

    out << indent(indentLevel) << outOfForLabel << ":" << endl;

    LabelManager::getInstance().popContinuePoint();
    LabelManager::getInstance().popCurrentBreakPoint();

    return out.str();
}

generateCode(DecoratedReturnStatement) {
    ostringstream out, epilogo;

    string indentation = indent(indentLevel);

    if (expression != NULL) {
        out << expression->generateCode(indentLevel + 1);
        if (expression->place != "$v0")
            out << indent(indentLevel) << "move $v0, " << expression->place << endl;
        
    }

    out << indentation << "#unregisterAll ..." << endl;
    out << unregisterAll() << endl;
    out << indentation << "#termino unregisterAll" << endl;
    out << indentation << "j " << function_end << endl;

    //TODO: COMPROBADO! EL EPILOGO ESTA MALO, HAY QUE CREARLO AL INICIO DE LA FUNCION Y METERLO A UN STACK!
    //NO TRATAR DE GENERARLO AQUI.

    epilogo << indentation << "#epilog " << endl;

    /* Load $ra */
    epilogo << indentation << "lw $ra, 0($fp)" << endl;

    list<string> toSaveRegisters = RegisterManager::getInstance().registersToSave();
    list<string>::iterator regToSaveIterator = toSaveRegisters.begin();
    int offset = 0;

    /* Load registers */
    regToSaveIterator = toSaveRegisters.begin();
    while (regToSaveIterator != toSaveRegisters.end()) {
        epilogo << indentation << "lw " << (*regToSaveIterator) << ", " << offset << "($sp)" << endl;
        offset += 4;
        regToSaveIterator++;
    }

    /* Load $fp */
    epilogo << indentation << "lw $fp, 4($fp)" << endl;

    epilogo << indentation << "addi $sp, $sp, " << offset << endl;
    epilogo << indentation << "#end of epilog" << endl;

    //out << epilogo.str();
    out << current_function_epilog << endl;
    //out << indent(indentLevel) << "jr $ra" << endl;
    return out.str();
}

generateCode(DecoratedBreakStatement) {
    ostringstream out; 

    out << unregisterBlocksLoop() << endl;

    out << indent(indentLevel) << "j " << LabelManager::getInstance().getCurrentBreakPoint() << endl;

    return out.str();
}

generateCode(DecoratedContinueStatement) {
    ostringstream out;

    out << indent(indentLevel) << "j " << LabelManager::getInstance().getCurrentContinuePoint() << endl;

    return out.str();
}

generateCode(DecoratedBlockStatement) {
    if (deepLevel >= MAX_DEEP_NESTING) {
        ostringstream out;
        out << "nesting level cannot be greater than " << MAX_DEEP_NESTING;
        ErrorHandler::getInstance().handleFatal(line, out.str());
    }
    ostringstream out;

    string indentation = indent(indentLevel);

    string displayAddress, displayItem;
    displayAddress = RegisterManager::getInstance().getTempRegister();
    displayItem = RegisterManager::getInstance().getTempRegister();

    int displayOffset = (deepLevel*4);

    out << indentation << "#generating scope registration logic..." << endl;
    out << indentation << "la " << displayAddress << ", display" << endl;
    out << indentation << "lw " << displayItem << ", " << displayOffset << "(" << displayAddress << ")" << endl;
    out << indentation << "addi $sp, $sp, -4" << endl;
    out << indentation << "sw " << displayItem << ", 0($sp)" << endl;
    out << indentation << "addi $sp, $sp, " << (-scopeSize) << "   #reservar el espacio para el scope" << endl;
    out << indentation << "sw $sp, " << displayOffset << "(" << displayAddress << ")" << endl;
    out << indentation << "#end of scope registration" << endl;

    RegisterManager::getInstance().freeRegister(displayAddress);
    RegisterManager::getInstance().freeRegister(displayItem);

    ostringstream unregisterLogic;
    unregisterLogic << indentation << "#starting scope unregistration code..." << endl;
    unregisterLogic << indentation << "addi $sp, $sp, " << scopeSize << endl;
    unregisterLogic << indentation << "la displayAddress , display" << endl;
    unregisterLogic << indentation << "lw  displayItem , 0($sp)" << endl;
    unregisterLogic << indentation << "addi $sp, $sp, 4" << endl;
    unregisterLogic << indentation << "sw displayItem, " << displayOffset << "(displayAddress)" << endl;
    unregisterLogic << indentation << "#end of scope unregistration" << endl;

    ContextManager::getInstance().pushUnregisterLogic(unregisterLogic.str(), this->belongsToLoop);

    ContextManager::getInstance().registerContext(this->deepLevel, this->context);

    list<DecoratedStatement*>::iterator it = statement_list->begin();
    out << indentation << "# scope level " << deepLevel << endl;

    while (it != statement_list->end()) {
        list<string> registersToSave = RegisterManager::getInstance().registersToSave();
        DecoratedMethodCallStatement *mc = dynamic_cast<DecoratedMethodCallStatement*>(*it);
        if (mc != NULL) {
            
            //generar codigo para guardar los registros a0...a3 en la pila!
            //cualquier llamada a metodo debe sacar los valores de la pila
            //NUNCA de los parametros!!!!!
            out << indentation << "#saving parameters because of method call" << endl;
            out << indentation << "addi $sp, $sp, -16" << endl;
            int i = 0;
            while (i < 4) {
                out << indentation << "sw $a" << i << ", " << i*4 << "($sp)" << endl;
                i++;
            }
            out << indentation << "#end saving parameters because of method call" << endl;
        }
        out << (*it)->generateCode(indentLevel + 1);
        if (mc != NULL) {
            out << indentation << "#restoring parameters because of method call" << endl;
            
            int i = 0;
            while (i < 4) {
                out << indentation << "lw $a" << i << ", " << i*4 << "($sp)" << endl;
                i++;
            }
            out << indentation << "addi $sp, $sp, 16" << endl;
            out << indentation << "#end restoring parameters because of method call" << endl;
        }
        it++;
    }
    out << indent(indentLevel) << "# end of scope level " << deepLevel << endl;

    displayAddress = RegisterManager::getInstance().getTempRegister();
    displayItem = RegisterManager::getInstance().getTempRegister();
    ContextManager::getInstance().unregisterContext(this->deepLevel);
    ContextManager::getInstance().popUnregisterLogic();

    out << indentation << "#starting scope unregistration code..." << endl;
    out << indentation << "addi $sp, $sp, " << scopeSize << endl;
    out << indentation << "la " << displayAddress << ", display" << endl;
    out << indentation << "lw " << displayItem << ", 0($sp)" << endl;
    out << indentation << "addi $sp, $sp, 4" << endl;
    out << indentation << "sw " << displayItem << ", " << displayOffset << "(" << displayAddress << ")" << endl;
    out << indentation << "#end of scope unregistration" << endl;

    RegisterManager::getInstance().freeRegister(displayAddress);
    RegisterManager::getInstance().freeRegister(displayItem);

    return out.str();
}
/*************************************************************/
generateCode(DecoratedClass) {
    ostringstream out;

    out << ".data" << endl;

    /*********************** Registering Variables **********************/
    map<string, Variable*> *variables = getSymbolTableInstance()->getVariables();
    map<string, Variable*>::iterator variable_it = variables->begin();

    while (variable_it != variables->end()) {
        Variable *variable = variable_it->second;

        out << variable_it->first ;
        SimpleVariable *simpleVariable = dynamic_cast<SimpleVariable*>(variable);
        if (simpleVariable != NULL) {
            out << ": .word ";
            if (variable->initialized) {
                if (((DecoratedIntConstant*)simpleVariable->initial_value) != NULL)
                    out << ((DecoratedIntConstant*)simpleVariable->initial_value)->value << endl;
                else
                    out << ((DecoratedBooleanConstant*)simpleVariable->initial_value)->value << endl;
            } else {
                out << 0 << endl;
            }
        } else {
            int size = ((ArrayVariable*)variable)->size;
            out << ": .space " << (size * 4) << " # " << size << " integers" << endl;
        }
        variable_it++;
    }

    out << "#special data" << endl;
    out << "display: .word 0:" << (MAX_DEEP_NESTING - 1) << endl;

    /*********************** Registering Strings **********************/

    map<string, string> *strings = getSymbolTableInstance()->getStrings();
    map<string, string>::iterator string_it = strings->begin();

    while (string_it != strings->end()) {
        out << string_it->second << ": .asciiz " << string_it->first << endl;
        string_it++;
    }

    out << endl << endl;

     /*********************** Registering Functions **********************/

    out << ".text" << endl;
    out << this->name << "_class_not_a_function:" << endl;
    out << "j main" << endl << endl;

    map<string, Function*> *functions = getSymbolTableInstance()->getFunctions();
    map<string, Function*>::iterator function = functions->begin();

    string indentation = indent(indentLevel);

    while (function != functions->end()) {
        ostringstream functionCode;

        out << indentation << function->first << ":" << endl;
        currentFunction = function->second;

        function_end = LabelManager::getInstance().getFunctionEndLabel();

        if (function->second->body != NULL) {
            functionCode << indentation << "# function body code" << endl;
            functionCode << function->second->body->generateCode(indentLevel + 1);
            functionCode << indentation << "# end of function body code" << endl;
        }

        if (function->first == "main") {
            functionCode << indentation << "li $v0, 10" << endl;
            functionCode << indentation << "syscall" << endl;
        }

        list<string> toSaveRegisters;
        int count = currentFunction->getParameterRegsNeededCount();
        for (int i = 0; i < count; i++) {
            ostringstream o;
            o << "$a" << i;
            toSaveRegisters.push_back(o.str());
        }

        ostringstream prologo, epilogo;

        prologo << indentation << "#prolog for " << function->first << endl;
        epilogo << indentation << "#epilog for " << function->first << endl;

        int extraParams = currentFunction->getParameterCountInStack();
        if (extraParams > 0)
            prologo << indentation << "addi $t0, $sp,"<< (count+extraParams)*4 << endl;
        

        prologo << indentation << "addi $sp, $sp, -32 " << endl;
        for (int i = 0; i < 8; i++) {
            prologo << indentation << "sw $s" << i << ", " << (i*4) << "($sp)" << endl;
        }

        

        prologo << indentation << "addi $sp, $sp, -8" << endl;

        /* Save $ra */
        prologo << indentation << "sw $ra, 0($sp)" << endl;

        /* Save $fp */
        prologo << indentation << "sw $fp, 4($sp)" << endl;

        /* Set $fp */
        prologo << indentation << "move $fp, $sp" << endl;

        int offset = 0;

        prologo << indentation << "addi $sp, $sp, -" << ((toSaveRegisters.size()+extraParams)*4) << endl;

        /* Save registers */
        list<string>::iterator regToSaveIterator = toSaveRegisters.begin();
        while (regToSaveIterator != toSaveRegisters.end()) {
            prologo << indentation << "sw " << (*regToSaveIterator) << ", " << offset << "($sp)" << endl;
            epilogo << indentation << "lw " << (*regToSaveIterator) << ", " << offset << "($sp)" << endl;
            offset += 4;
            regToSaveIterator++;
        }

        for (int  i = 0; i < extraParams; i++) {
            prologo << indentation << "lw $t1, " << (i - extraParams)*4 << "($t0)" << endl;
            prologo << indentation << "sw $t1, " << offset << "($sp)" << endl;
            offset += 4;
        }

        prologo << indentation << "#end of prolog for " << function->first << endl;
        
        epilogo << indentation << "addi $sp, $sp, " << ((toSaveRegisters.size()+extraParams)*4) << endl;
        //epilogo << indentation << "move $sp, $sp" << endl;
        epilogo << indentation << "lw $fp, 4($sp)" << endl;
        epilogo << indentation << "lw $ra, 0($sp)" << endl;
        epilogo << indentation << "addi $sp, $sp, 8" << endl;

        for (int i = 0; i < 8; i++) {
            epilogo << indentation << "lw $s" << i << ", " << (i*4) << "($sp)" << endl;
        }

        epilogo << indentation << "addi $sp, $sp, 32" << endl;
        epilogo << indentation << "#end of epilog for " << function->first << endl;

        current_function_epilog = epilogo.str();

        RegisterManager::getInstance().freeAllRegisters();

        out << prologo.str();
        out << functionCode.str();
        out << function_end << ":" << endl;
        out << current_function_epilog;
        out << indentation << "jr $ra" << endl;
        out << endl << endl;

        function++;
    }
    return out.str();
}
/*************************************************************/
%operation %virtual string getLocation([DecoratedLValue *this], int indentLevel);

getLocation(DecoratedLValue) {
    ostringstream out;

    string reg;
    reg = RegisterManager::getInstance().getSavedRegister();

    Context *context = ContextManager::getInstance().getContext(this->deepLevel);

    string indentation;
    indentation = indent(indentLevel);

    out << indentation << "#var " << variable_name << endl;

    if (isGlobal) {
        
        out << indentation << "la " << reg << ", " << variable_name << endl;
        if (array_index != NULL) {
            out << array_index->generateCode(indentLevel + 1);
            out << indent(indentLevel + 1) << "sll " << array_index->place 
                << ", " << array_index->place << ", 2" << "# multiply by 4" << endl;
            out << indentation << "add " << reg << ", " << reg << ", " 
                << array_index->place << endl;
        }
        
    } else if (isParameter) {
        out << indentation << "addi " << reg << ", $fp, " << this->offset << endl;
        out << indentation << "#param: " << variable_name << " offset " << this->offset << endl;
    } else {
        out << indentation << "la " << reg << ", display" << endl;
        out << indentation << "addi " << reg << ", " << reg << ", " << (this->deepLevel*4) << endl;
        out << indentation << "lw " << reg << ", 0(" << reg << ")" << endl;
        out << indentation << "addi " << reg << ", " << reg << ", " << context->transformOffset(this->offset) << endl;
        out << indentation << "#local: " << variable_name << " offset " << this->offset
            << " level " << this->deepLevel << endl;
    }
    this->place =  reg;

    return out.str();
}


/****************************
param n 
param n-1 
.
.
.
param 5 
$ra
$fp





*****************************/