%decls %{
#include <string>
#include <list>
#include <cstring>
#include <cstdlib>
#include <sstream>
#include <cstddef>

#include "Value.h"
#include "Util.h"
#include "error_handler.h"
#include "register_manager.h"
using namespace std;

class Statement;
typedef list<Statement *> StatementList;

class Expression;
typedef list<Expression *> ExpressionList;

class VariableDef;
typedef list<VariableDef *> VariableDefList;

class ParameterDef;
typedef list<ParameterDef *> ParameterDefList;

class MethodDef;
typedef list<MethodDef *> MethodDefList;

class BlockStatement;
void setStatementList(BlockStatement *block, StatementList *stList);
void addStatement(BlockStatement *block, Statement *statement);

typedef enum {
	OpAdd,
	OpSub,
	OpMul,
	OpDiv,
	OpMod,
	OpAnd,
	OpOr,
	OpNot,
	OpGT,
	OpLT,
	OpGTE,
	OpLTE,
	OpEq,
	OpNotEq,
	OpRShift,
	OpLShift,
	OpRot
} ExpressionOperator;

typedef union {
	int int_value;
	bool bool_value;
	char *string_value;
} union_constants;


/*** Typedefs for Decorated Nodes ***/
class DecoratedExpression;
typedef list<DecoratedExpression *> DecoratedExpressionList;

class DecoratedStatement;
typedef list<DecoratedStatement *> DecoratedStatementList;
%}

%{
#include "decaf_tree.h"

string OperatorToString(ExpressionOperator oper) {
	switch (oper)
	{
		case OpAdd: return "+";
		case OpSub: return "-";
		case OpMul: return "*";
		case OpDiv: return "/";
		case OpMod: return "%";
		case OpAnd: return "&&";
		case OpOr: return "||";
		case OpNot: return "!";
		case OpGT: return ">";
		case OpLT: return "<";
		case OpGTE: return ">=";
		case OpLTE: return "<=";
		case OpEq: return "==";
		case OpNotEq: return "!=";
		case OpRShift: return ">>";
		case OpLShift: return "<<";
		case OpRot: return "rot";
		default:
				return "Unknown";
	}
}
%}

%header "decaf_tree.h"
%output "decaf_tree.cpp"

%option lang="C++"

%node DNode %abstract %typedef

%node MainNode DNode %abstract

%node ClassDef MainNode = {
    string name;
    VariableDefList *field_def_list;
    MethodDefList *method_def_list;
}

/****Definitions Tree****/
%node Definition DNode %abstract

%end %{
void addFieldDef(ClassDef *classDef, VariableDef *field_def) {
	if (classDef->field_def_list == 0)
		classDef->field_def_list = new VariableDefList;
	classDef->field_def_list->push_back(field_def);
}

void addMethod(ClassDef *classDef, MethodDef *method_def) {
	if (classDef->method_def_list == 0)
		classDef->method_def_list = new MethodDefList;
	classDef->method_def_list->push_back(method_def);
}
%}

%node VariableDef Definition = {
	string variable_name;
	int line;
	int column;
	%nocreate Type variable_type;
	%nocreate bool is_array_def = {false};
	%nocreate int array_dimension = {0};
	%nocreate Expression* initial_value = {0};
}

%node ParameterDef Definition = {
	string parameter_name;
	Type parameter_type;
}

%node MethodDef Definition = {
	string method_name;
	%nocreate Type method_return_type;
	%nocreate ParameterDefList *method_parameters;
	%nocreate Statement *method_body;
}
/*=========================*/

/****Expressions Tree****/
%node Expression DNode %abstract

%node BinaryExpression Expression = {
	Expression *left;
	Expression *right;
	ExpressionOperator  expression_operator;
}
%node UnaryExpression Expression = {
	Expression *expression;
	ExpressionOperator  expression_operator;
}
%node LValueExpression Expression = {
	string variable_name;
	Expression *array_index;
}
%node MethodCallExpression Expression = {
	string method_name;
	ExpressionList *method_arguments;
}
%node IntConstantExpression Expression = {
	%nocreate Type constant_type = {Int};
	int int_value;
}

%node RealConstantExpression Expression = {
	%nocreate Type constant_type = {Real};
	float float_value;
}

%node BooleanConstantExpression Expression = {
	%nocreate Type constant_type = {Boolean};
	bool bool_value;
}

%node StringConstantExpression Expression = {
	%nocreate Type constant_type = {String};
	char *string_value;
}
/*=========================*/

/****Statements Tree****/
%node Statement DNode %abstract = {
	int line;
	int column;
}
%node AssignmentStatement Statement = {
	Expression *lvalue;
	Expression *expr;
}
%node MethodCallStatement Statement = {
	string name;
	ExpressionList *arguments;
}
%node IfStatement Statement = {
	Expression *condition;
	Statement *true_part;
	Statement *false_part;
}
%node WhileStatement Statement = {
	Expression *condition;
	Statement *loop_body;
}
%node ForStatement Statement = {
	Statement *assignment_list1;
	Expression *condition;
	Statement *assignment_list2;
	Statement *loop_body;
}
%node ReturnStatement Statement = {
	Expression *expr;
}
%node BreakStatement Statement
%node ContinueStatement Statement
%node BlockStatement Statement = {
	%nocreate StatementList *statement_list = {0};
}
%node PrintStatement Statement = {
	ExpressionList *arguments;
}

%end %{
void setStatementList(BlockStatement *block, StatementList *stList) {
	block->statement_list = stList;
}

void addStatement(BlockStatement *block, Statement *statement) {
	if (block->statement_list == 0)
		block->statement_list = new StatementList;

	block->statement_list->push_back(statement);
}
%}
/*=====================================================================*/

%operation %virtual string toString(DNode *this);

toString(ClassDef) {
	ostringstream out;

	out << "class " << name << "\n";
	out << "{" << "\n";

	if (field_def_list != 0)
		out << ListToString(field_def_list, ";\n", true) << "\n";

	if (method_def_list != 0)
		out << ListToString(method_def_list, "\n\n", true);

	out << "}" << endl;

	return out.str();
}

toString(VariableDef) {
	ostringstream out;

	out << "//Linea: " << line << ": Columna: " << column << endl;
	out << TypeToString(variable_type) << " " << variable_name;

	if (is_array_def)
		out << "[" << array_dimension << "]";

	if (initial_value != 0)
		out << " = " + initial_value->toString();

	return out.str();
}

toString(ParameterDef) {
	return TypeToString(parameter_type) + " " + parameter_name;
}

toString(MethodDef) {
	ostringstream out;

	out << TypeToString(method_return_type) << " " << method_name << "(";
	if (method_parameters != 0)
		out << ListToString(method_parameters, ", ", false);
	out << ")" << endl;
	out << method_body->toString() << endl;

	return out.str();
}

toString(BinaryExpression) {
    ostringstream out;
    
    out << left->toString() << OperatorToString(expression_operator) << right->toString();
    
    return out.str();
}

toString(UnaryExpression) {
    ostringstream out;
    
    out << OperatorToString(expression_operator) << expression->toString();
    
    return out.str();
}

toString(LValueExpression) {
	ostringstream out;

	out << this->variable_name;

	if (array_index != 0)
		out << "[" << array_index->toString() << "]";

	return out.str();
}

toString(MethodCallExpression) {
	ostringstream out;

	out << this->method_name << "(" << ListToString(method_arguments, ", ", false) << ")";

	return out.str();
}

toString(IntConstantExpression) {
	ostringstream out;

	out << int_value ;
	return out.str();
}

toString(RealConstantExpression) {
	ostringstream out;

	out << float_value;
	return out.str();
}

toString(BooleanConstantExpression) {
	ostringstream out;

	out << bool_value;
	return out.str();
}

toString(StringConstantExpression) {
	ostringstream out;

	out << string_value;
	return out.str();
}

/* toString for statement */
toString(AssignmentStatement) {
	ostringstream out;

	out << "// Linea " << line << " Columna " << column << "\n"; 
	out << lvalue->toString() << " = " << expr->toString() << ";";

	return out.str();
}

toString(MethodCallStatement) {
	return this->name + "(" + ListToString(arguments, ", ", false) + ");";
}

toString(IfStatement) {
	ostringstream out;

	out << "if (" << condition->toString() << ")" << endl;
	out << true_part->toString() << endl;

	if (false_part != 0) {
		out << "else" << endl;
		out << false_part->toString() << endl;
	}

	return out.str();
}

toString(WhileStatement) {
	ostringstream out;

	out << "while (" << condition->toString() << ")" << endl;
	out << "{" << loop_body->toString() << endl << "}";

	return out.str();
}

toString(ForStatement) {
	ostringstream out;

	out << "for (" << assignment_list1->toString();
	out << ";" << condition->toString();
	out << ";" << assignment_list2->toString();
	out << "{" << endl << loop_body->toString() << endl << "}";

	return out.str();
}

toString(ReturnStatement) {
	ostringstream out;
	
	out << "return ";
	if (expr != NULL) {
		out << expr->toString();
	}
	out << ";";
	
	return out.str();
}

toString(BreakStatement) {
	return "break;";
}

toString(ContinueStatement) {
	return "continue;";
}

toString(BlockStatement) {
	ostringstream out;

	out << "{" << endl;

	if (statement_list != 0)
		out << ListToString(statement_list, "\n", true);

	out << "}";

	return out.str();
}

toString(PrintStatement) {
	return  "print (" + ListToString(arguments, ", ", false) + ");";
}

%include "decaf_types.tc"

/*=====================================================================*/
%operation %virtual DecoratedNode* validateSemantics(DNode *this);

/*** Validate Semantics for Expressions ***/
/*=====================================================================*/
validateSemantics(ClassDef) {
    list<VariableDef*>::iterator variable_iterator = field_def_list->begin();
    
    while(variable_iterator != field_def_list->end()) {
        VariableDef * field_def = *variable_iterator;
        field_def->registerDefinition();
        variable_iterator++;
    }
    
    list<MethodDef*>::iterator method_iterator = method_def_list->begin();
    
    while(method_iterator != method_def_list->end()) {
        MethodDef * method_def = *method_iterator;
        method_def->registerDefinition();
        method_iterator++;
    }
    
    /************ Check method bodies. ************/
    method_iterator = method_def_list->begin();
    DecoratedBlockStatement *main_block = NULL;
    while(method_iterator != method_def_list->end()) {
        MethodDef * method_def = *method_iterator;
        if (method_def->method_name == "main") {
        	main_block = method_def->checkBody();
        } else {
        	method_def->checkBody();
        }
        method_iterator++;
    }

    DecoratedClass *decorated_class = new DecoratedClass(this->name);
    decorated_class->main = main_block;
    
    return decorated_class;
}

validateSemantics(BinaryExpression) {
    cout << "validating binary expression semantics" << endl;
    
    DecoratedExpression *dLeft = (DecoratedExpression*)(left->validateSemantics());
    DecoratedExpression *dRight = (DecoratedExpression*)(right->validateSemantics());
    
    if (dLeft == NULL || dRight == NULL)
        return NULL;
    
    if (!dLeft->type->isEquivalent(dRight->type)) {
        ErrorHandler::getInstance().handleError("type mismatch for operator " + 
                                                OperatorToString(expression_operator) +
                                                " for types " + dLeft->type->stringValue() +
                                                " and " + dRight->type->stringValue());
        cout << dLeft->type->stringValue() << " not equivalent to" << dRight->type->stringValue() << endl;
        return NULL;
    }
    cout << "before testing string type" << endl;
    if (dynamic_cast<StringType*>(dLeft->type) != NULL) {
        ErrorHandler::getInstance().handleError("type mismatch for operator " + 
                                                OperatorToString(expression_operator) +
                                                " for types " + dLeft->type->stringValue() +
                                                " and " + dRight->type->stringValue());
        return NULL;
    }
    
    ExpressionType      *type;
    
    cout << "operator " << OperatorToString(expression_operator) << endl;
    
    if (dynamic_cast<FloatType*>(dLeft->type) != NULL
        || dynamic_cast<FloatType*>(dRight->type) != NULL) {
        
        type = new FloatType();
        cout << "left side is float " << endl;
    }
    if (dynamic_cast<BooleanType*>(dLeft->type) != NULL) {
        type = new BooleanType();
        
        cout << "left side is boolean " << endl;
    }
    if (dynamic_cast<IntegerType*>(dLeft->type) != NULL) {
        type = new IntegerType();
        
        cout << "left side is integer " << endl;
    }
    
    
    switch(expression_operator) {
        case OpAdd:
            if (type->isNumeric())
                return new DecoratedAddExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpSub:
            if (type->isNumeric())
                return new DecoratedSubExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpMul:
            if (type->isNumeric())
                return new DecoratedMultExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpDiv:
            if (type->isNumeric())
                return new DecoratedDivExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpMod:
            if (type->isNumeric())
                return new DecoratedModExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpAnd:
            if (type->isBoolean())
                return new DecoratedAndExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpOr:
            if (type->isBoolean())
                return new DecoratedOrExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpGT:
            if (type->isBoolean())
                return new DecoratedGTExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpLT:
            if (type->isBoolean())
                return new DecoratedLTExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpGTE:
            if (type->isBoolean())
                return new DecoratedGTEExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpLTE:
            if (type->isBoolean())
                return new DecoratedLTEExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpEq:
            if (type->isBoolean())
                return new DecoratedEqExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpNotEq:
            if (type->isBoolean())
                return new DecoratedNotEqExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpRShift:
            if (type->isNumeric())
                return new DecoratedRShiftExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpLShift:
            if (type->isNumeric())
                return new DecoratedLShiftExpression(type, dLeft, dRight);
            else
                return NULL;
        case OpRot:
            if (type->isNumeric())
                return new DecoratedRotExpression(type, dLeft, dRight);
            else
                return NULL;
        default:
            return NULL;
    }
}

validateSemantics(UnaryExpression) {
    DecoratedExpression *dExpression = (DecoratedExpression*)expression->validateSemantics();
    
    if (dExpression == NULL)
        return NULL;
        
    ExpressionType  *type;
    
    switch(expression_operator) {
        case OpSub:
            if (dExpression->type->isNumeric())
                return new DecoratedNegExpression(dExpression->type, dExpression);
            else
                return NULL;
        case OpNot:
            if (dExpression->type->isBoolean())
                return new DecoratedNotExpression(dExpression->type, dExpression);
            else
                return NULL;
        default:
            return NULL;
    }
}

validateSemantics(LValueExpression) {
    cout << "validating lvalue semantics " << endl;
    DecoratedExpression *d_array_index = NULL;
    if (array_index != NULL)
        d_array_index = (DecoratedExpression*)array_index->validateSemantics();
    return new DecoratedLValue(new IntegerType(), variable_name, d_array_index);
}

validateSemantics(MethodCallExpression) {
    cout << "validating method call expression " << endl;
    list<Expression*>::iterator expression_iterator = method_arguments->begin();
    
    cout << "parameters: " << endl;
    DecoratedExpressionList *d_arguments = new DecoratedExpressionList;

    while (expression_iterator != method_arguments->end()) {
        Expression *expression = *expression_iterator;
        DecoratedExpression *d_expr = (DecoratedExpression*)expression->validateSemantics();
        d_arguments->push_back(d_expr);
        
        expression_iterator++;
    }

    return new DecoratedMethodCallExpression(new IntegerType(), method_name, d_arguments);
}

validateSemantics(IntConstantExpression) {
    cout << "validating int constant semantics " << endl;
    return new DecoratedIntConstant(new IntegerType(), int_value);
}

validateSemantics(RealConstantExpression) {
    cout << "validating real constant semantics " << endl;
    /*TODO: instancia el nuevo nodo decorado*/
}

validateSemantics(BooleanConstantExpression) {
    cout << "validating boolean constant semantics " << endl;
    return new DecoratedBooleanConstant(new BooleanType(), bool_value);
}

validateSemantics(StringConstantExpression) {
    cout << "validating string constant semantics " << endl;
    /*TODO: instancia el nuevo nodo decorado*/
}

/*** Validate Semantics for Statements ***/
/*=====================================================================*/
validateSemantics(AssignmentStatement) {
    cout << "validating assignment statement semantics" << endl;
    DecoratedLValue *d_lvalue = (DecoratedLValue*)lvalue->validateSemantics();
    cout << "after lvalue semantics" << endl;
    DecoratedExpression *d_expr = (DecoratedExpression*)expr->validateSemantics();

    return new DecoratedAssignmentStatement(d_lvalue, d_expr);
}

validateSemantics(MethodCallStatement) {
    list<Expression*>::iterator expression_iterator = arguments->begin();
    
    DecoratedExpressionList *d_arguments = new DecoratedExpressionList;
    while (expression_iterator != arguments->end()) {
        Expression *expression = *expression_iterator;
        DecoratedExpression *d_expr = (DecoratedExpression*)expression->validateSemantics();

        d_arguments->push_back(d_expr);
        
        expression_iterator++;
    }

    return new DecoratedMethodCallStatement(d_arguments);
}

validateSemantics(IfStatement) {
    cout << "validating if statement semantics " << endl;
    condition->validateSemantics();
    
    cout << "validateSemantics if true part " << endl;
    true_part->validateSemantics();
    
    if (false_part != NULL)
        false_part->validateSemantics();
}

validateSemantics(WhileStatement) {
    condition->validateSemantics();
    loop_body->validateSemantics();
}

validateSemantics(ForStatement) {
    DecoratedStatement *d_assignment_list1 = (DecoratedStatement*)assignment_list1->validateSemantics();
    condition->validateSemantics();
    assignment_list2->validateSemantics();
    loop_body->validateSemantics();
}

validateSemantics(ReturnStatement) {
    cout << "validating return statement semantics " << endl;
    DecoratedExpression *decorated_expression = NULL;
    if (expr != NULL) {
        decorated_expression = (DecoratedExpression*)expr->validateSemantics();
    }
    return new DecoratedReturnStatement(decorated_expression);
}

validateSemantics(BreakStatement) {
    /*TODO: instancia el nuevo nodo decorado*/
    return new DecoratedBreakStatement();
}

validateSemantics(ContinueStatement) {
    /*TODO: instancia el nuevo nodo decorado*/
    return new DecoratedContinueStatement();
}

validateSemantics(BlockStatement) {
    list<Statement*>::iterator statement_iterator = statement_list->begin();
    
    DecoratedStatementList  *decorated_statement_list = new DecoratedStatementList;
    
    while (statement_iterator != statement_list->end()) {
        Statement *statement = *statement_iterator;
        DecoratedStatement *decorated_statement =  (DecoratedStatement*)statement->validateSemantics();
        decorated_statement_list->push_back(decorated_statement);
        
        statement_iterator++;
    }
    
    return new DecoratedBlockStatement(decorated_statement_list);
}

validateSemantics(PrintStatement) {
	list<Expression*>::iterator expression_iterator = arguments->begin();
    
    DecoratedExpressionList *d_arguments = new DecoratedExpressionList;
    while (expression_iterator != arguments->end()) {
        Expression *expression = *expression_iterator;
        DecoratedExpression *d_expr = (DecoratedExpression*)expression->validateSemantics();

        d_arguments->push_back(d_expr);
        
        expression_iterator++;
    }

    return new DecoratedMethodCallStatement(d_arguments);
}

validateSemantics(VariableDef) {
    /* DO NOTHING */
    return NULL;
}

validateSemantics(ParameterDef) {
    /* DO NOTHING */
    return NULL;
}

validateSemantics(MethodDef) {
    /* DO NOTHING */
    return NULL;
}


/*=====================================================================*/
%operation %virtual void registerDefinition(Definition *this);

registerDefinition(MethodDef) {

}

registerDefinition(VariableDef) {

}

registerDefinition(ParameterDef) {

}

/*=====================================================================*/
%operation %virtual DecoratedBlockStatement* checkBody(MethodDef *this);

checkBody(MethodDef) {
    return (DecoratedBlockStatement*)method_body->validateSemantics();
}

%include "decaf_semantic_tree.tc"